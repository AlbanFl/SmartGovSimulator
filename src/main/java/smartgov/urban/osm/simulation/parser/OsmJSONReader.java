package smartgov.urban.osm.simulation.parser;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.locationtech.jts.geom.Coordinate;
import org.locationtech.jts.geom.GeometryFactory;

import smartgov.urban.osm.environment.OsmContext;
import smartgov.urban.osm.environment.city.Building;
import smartgov.urban.osm.environment.city.BuildingType;
import smartgov.urban.osm.environment.city.DefaultBuilding;
import smartgov.urban.osm.environment.city.Home;
import smartgov.urban.osm.environment.city.ParkingSpot;
import smartgov.urban.osm.environment.city.WorkOffice;
import smartgov.urban.osm.environment.graph.OsmArc;
import smartgov.urban.osm.environment.graph.OsmNode;
import smartgov.urban.osm.environment.graph.Road;
import smartgov.urban.osm.simulation.scenario.OsmScenario;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * Class used to parse OSM json inputs, generated by the SmartGov OSMParser.
 * 
 * @author pbreugnot
 *
 * @param <T> OsmEnvironment type
 */
public class OsmJSONReader {
	
	protected OsmScenario scenario; // Used to retrieve Arc and Node creators.
	static GeometryFactory geoFactory = new GeometryFactory();
	protected ObjectMapper objectMapper;
	
	
	public OsmJSONReader(OsmScenario scenario) {
		this.scenario = scenario;
		// Jackson Object Mapper
		this.objectMapper = new ObjectMapper();
	}

	
	public Map<String, OsmArc> readArcs(String edgeFile, Map<String, OsmNode> nodes, List<Road> roads){
		Map<String, OsmArc> edges = new HashMap<>();

		try{
			JsonNode rootNode = objectMapper.readTree(new File(edgeFile));
			int index = 0;
			while(true){
				JsonNode currentEdge = rootNode.get(String.valueOf(index));
				if(currentEdge == null){
					break;
				}

				OsmNode beginNode = (OsmNode) nodes.get(String.valueOf(currentEdge.get("startNode")));
				OsmNode targetNode = (OsmNode) nodes.get(String.valueOf(currentEdge.get("targetNode")));

				Coordinate[] coordinates1 = new Coordinate[2];
				coordinates1[0] = beginNode.getPosition();
				coordinates1[1] = targetNode.getPosition();
				int lanes = 0;
				try {
					lanes = currentEdge.get("lanes").asInt();
				} catch (Exception e) {
					lanes = 0;
				}
				
				String type = currentEdge.get("highway")!= null ? currentEdge.get("highway").asText() : "";
				
				
				/*
				 * Bug here, TODO know why, disable this and every road become twoway instead of oneway
				 */
				//*/
				// TODO : Need to check this.
				if(currentEdge.get("backward").asBoolean()){
//					OsmArc edgeOSM = new OsmArc(
//							geography,
//							String.valueOf(index),
//
//							beginNode,
//							targetNode,
//							(double) currentEdge.get("distance"),
//							(boolean) currentEdge.get("backward"),
//							(boolean) currentEdge.get("forward"),
//							roadLine, 
//							lanes,
//							type);
//
//					edgesOSM.add(edgeOSM);

					OsmArc edge = scenario.createArc(
							String.valueOf(index),
							roads.get(currentEdge.get("road").asInt()),
							beginNode,
							targetNode,
							lanes,
							type);

					edges.put(edge.getId(), edge);					
				}
				//*/
				index++;
			}

		} catch (Exception e) {
			System.out.println("Error in Read Edges: ");
			e.printStackTrace();
		}
		return edges;
	}	

	public Map<String, OsmNode> parseNodeFile(String nodeFile){
		Map<String, OsmNode> nodes = new HashMap<>();

		try{
			JsonNode rootNode = objectMapper.readTree(new File(nodeFile));
			int index = 0;
			while(true){
				JsonNode currentNode = rootNode.get(String.valueOf(index));

				if(currentNode == null){
					break;
				}
				OsmNode node = new OsmNode(
						String.valueOf(index),
						new Coordinate(currentNode.get("lon").asDouble(), currentNode.get("lat").asDouble()));
				nodes.put(node.getId(), node);
				index++;
			}
		} catch (Exception e) {
			System.out.println("Error in Parsing Nodes: ");
			e.printStackTrace();
		}

		return nodes;
	}

	/**
	 * Use to get dead end in graph. Nodes with no incoming edges will be spawn nodes (agent creation) and nodes with no outgoing edges will be despawn nodes (agent destruction).
	 * @return Array of id node list, where the first list contains spawn nodes and the second list contains despawn nodes
	 */
	public List<Integer>[] getSpawnNodes(String edgeFile){
		long beginTime = System.currentTimeMillis();
		Map<Integer, Integer> incomingNodeNumber = new HashMap<>();
		Map<Integer, Integer> outgoingNodeNumber = new HashMap<>();
		List<Integer> despawnNodeId = new ArrayList<>();
		List<Integer> spawnNodeId = new ArrayList<>();
		
		@SuppressWarnings("unchecked")
		List<Integer>[] listOfNodeIds = new ArrayList[2];
		
		try{
			JsonNode rootNode = objectMapper.readTree(new File(edgeFile));
			int index = 0;
			while(true){
				JsonNode currentEdge = rootNode.get(String.valueOf(index));
				if(currentEdge == null){
					break;
				}
				if(currentEdge.get("backward").asBoolean()){
					int beginNodeId = currentEdge.get("startNode").asInt();
					int targetNodeId = currentEdge.get("targetNode").asInt();
					if(outgoingNodeNumber.containsKey(beginNodeId)){
						outgoingNodeNumber.put(beginNodeId, outgoingNodeNumber.get(beginNodeId) + 1);
					} else {
						outgoingNodeNumber.put(beginNodeId, 1);
					}
					if(incomingNodeNumber.containsKey(targetNodeId)){
						incomingNodeNumber.put(targetNodeId, incomingNodeNumber.get(targetNodeId) + 1);
					} else {
						incomingNodeNumber.put(targetNodeId, 1);
					}
					
				}
				index++;
			}
		} catch (Exception e){
			System.out.println("Error in getSpawnNodes: ");
			e.printStackTrace();
		}

		for(Entry<Integer, Integer> element : outgoingNodeNumber.entrySet()){
			//node got only one outgoing edge and no incoming edge
			if(element.getValue() >= 1 && !incomingNodeNumber.containsKey(element.getKey())){//get(element.getKey()) == 0){
				//create a spawn node
				spawnNodeId.add(element.getKey()); //add node id
				//System.out.println("Spawn node identified: " + element.getKey());
			}
		}
		for(Entry<Integer, Integer> element : incomingNodeNumber.entrySet()){
			//node got only one incoming edge and no outgoing edge
			if(element.getValue() >= 1 && !outgoingNodeNumber.containsKey(element.getKey())){//get(element.getKey()) == 0){
				//create a despawn node
				despawnNodeId.add(element.getKey()); //add node id
				//System.out.println("Despawn node identified: " + element.getKey());
			}
		}
		listOfNodeIds[0] = spawnNodeId;
		listOfNodeIds[1] = despawnNodeId;
		System.out.println("Time to process spawns node identification: " + (System.currentTimeMillis() - beginTime) + "ms.");
		return listOfNodeIds;
	}

//	private static SurfaceShape createSurfaceShape(Coordinate[] coordinates, double elevation){
//		List<Position> positions = new ArrayList<>();
//		for(int i = 0; i < coordinates.length; i++){
//			positions.add(new Position(Angle.fromDegrees(coordinates[i].x), Angle.fromDegrees(coordinates[i].y), elevation));
//		}
//		return new SurfacePolygon(positions);
//	}

	private static Coordinate[] convertNodeIDtoCoordinate(String[] nodesID, List<Coordinate> coords){
		Coordinate[] coordinates = new Coordinate[nodesID.length];
		for(int i = 0; i < nodesID.length; i++){
			int index = Integer.valueOf(nodesID[i]);
			coordinates[i] = coords.get(index);
		}
		return coordinates;
	}

	public List<Building> parseBuildingFile(String buildingFile, String nodeBuildingFile){
		List<Building> buildings = new ArrayList<>();
		List<Coordinate> coordinatesNodes = new ArrayList<>();

		//Parse building nodes
		try{
			JsonNode rootNode = objectMapper.readTree(new File(nodeBuildingFile));
			int index = 0;
			while(true){
				JsonNode currentNode = rootNode.get(String.valueOf(index));

				if(currentNode == null){
					break;
				}
				Coordinate coordinate = new Coordinate(currentNode.get("lon").asDouble(), currentNode.get("lat").asDouble());
				coordinatesNodes.add(coordinate);
				index++;
			}
		} catch (FileNotFoundException e) {
			System.out.println("No nodeBuildingFile found. No building will be load.");
			return new ArrayList<>();
		} catch (Exception e){
			System.out.println("Error in parsing building file: ");
			e.printStackTrace();
		}

		//Parse buildings
		try{
			JsonNode rootNode = objectMapper.readTree(new File(buildingFile));

			int index = 0;
			int idBuilding = 0;
			List<String> amenities_activities = Arrays.asList("bar","pub","restaurant","biergarten","cafe","fast_food","food_court","ice_cream","pub","restaurant",
					"college","kindergarten","library","public_bookcase","school","music_school","driving_school","language_school","university", "fuel", "bicycle_rental",
					"bus_station","car_rental","taxi","car_wash","ferry_terminal", "atm","bank","bureau_de_change", "baby_hatch","clinic", "dentist","doctors",
					"hospital","nursing_home","pharmacy","social_facility","veterinary","arts_centre","brothel","casino","cinema","community_centre","fountain",
					"gambling","nightclub","planetarium","social_centre","stripclub","studio","swingerclub","theatre", "animal_boarding", "animal_shelter","courthouse",
					"coworking_space","crematorium","dive_centre","dojo","embassy","fire_station","gym","internet_cafe","marketplace","police","post_office","townhall");
			List<String> building_activities = Arrays.asList("stable", "shop", "kiosk", "garages", "hangar", "stable", "cowshed", "digester",
					"commercial","office","industrial","retail","warehouse","port","cathedral","chapel","church","mosque","temple","synagogue","shrine",
					"civic","hospital","school","stadium","train_station","transportation","university","public");
			List<String> leisure_activities = Arrays.asList("adult_gaming_centre","amusement_arcade","beach_resort","dance","hackerspace","ice_rink","pitch",
					"sports_centre","stadium","summer_camp","swimming_area","water_park","dog_park", "bird_hide", "bandstand", "firepit", "fishing", "garden",
					"golf_course", "marina", "miniature_golf", "nature_reserve", "park", "playground", "slipway", "track", "wildlife_hide", "swimming_pool");
			
			while(true){
				JsonNode currentBuilding = rootNode.get(String.valueOf(index));
				Map<String, String> attributes = new HashMap<>();
				Coordinate[] coords = null;
				if(currentBuilding == null){
					break;
				}

				int nodeLength = 0;
				for(Iterator<?> iterator = currentBuilding.fieldNames(); iterator.hasNext();){
					String key = (String) iterator.next();
					if(key.equalsIgnoreCase("nodes")){
						String[] nodes = currentBuilding.get(key).asText().split(" ");
						nodeLength = nodes.length;
						//Convert nodesID to coordinates
						coords = convertNodeIDtoCoordinate(nodes, coordinatesNodes);
						if(nodeLength == 1){
							
							String[] nodesTemp = new String[4];
							nodesTemp[0] = nodes[0];
							nodesTemp[1] = nodes[0];
							nodesTemp[2] = nodes[0];
							nodesTemp[3] = nodes[0];
							coords = convertNodeIDtoCoordinate(nodesTemp, coordinatesNodes);
						} else if (nodes[0] != nodes[nodeLength - 1]){
							//Need to check if nodes form a closed linestring to avoid IllegalArgumentException when loading context
							String[] nodesTemp = new String[nodeLength + 1];
							for(int j = 0; j < nodeLength; j++){
								nodesTemp[j] = nodes[j];
							}
							nodesTemp[nodeLength] = nodes[0];
							coords = convertNodeIDtoCoordinate(nodesTemp, coordinatesNodes);
						}
						
						//System.out.println("Size of coords: " + coords.length);
					} else {
						attributes.put(key, currentBuilding.get(key).asText());
					}
				}

				Building building = null;
				BuildingType type = null;
				
				
				if(coords.length<=1) // Les nodes seuls ne peuvent pas representer une residence
					type = BuildingType.WORKOFFICE;
				else if(attributes.containsKey("shop") && attributes.get("shop") != ""){
					type = BuildingType.WORKOFFICE;
				}
				else if(attributes.containsKey("leisure") && attributes.get("leisure") != "" && leisure_activities.contains(attributes.get("leisure"))){
					type =  BuildingType.WORKOFFICE;
				}
				else if (attributes.containsKey("amenity") && attributes.get("amenity") != "" && amenities_activities.contains(attributes.get("amenity"))){
						type =  BuildingType.WORKOFFICE;
				}
				else if(attributes.containsKey("landuse") && attributes.get("landuse") != ""){
					if(attributes.get("landuse").equalsIgnoreCase("residential"))
						type= BuildingType.HOME;
					else
						type =  BuildingType.WORKOFFICE;
				}
				else if(attributes.containsKey("building") && attributes.get("building") != ""){	
					if (building_activities.contains(attributes.get("building")))
						type =  BuildingType.WORKOFFICE;
					else type = BuildingType.HOME;
				} else {
					//Default case
					type = BuildingType.MIXED;
				}
				if(type!=null){
					switch (type) {
						case WORKOFFICE:
							building = new WorkOffice(String.valueOf(idBuilding), attributes, coords);
							break;
						case HOME:
							building = new Home(String.valueOf(idBuilding), attributes, coords);
							break;
						default:
							building = new DefaultBuilding(String.valueOf(idBuilding), attributes, coords);
							break;
					}
				
					building.setType(type);
					buildings.add(building);
					idBuilding++;
				} else {
					buildings.add(building);
				}
				index++;
			}

		} catch (Exception e){
			System.out.println("Error in parsing building file: ");
			e.printStackTrace();
		}
		/*
		for(int i = 0; i < buildings.size(); i++){
			Building building = buildings.get(i);
			context.add(building);
			geography.move(building, geoFactory.createPolygon(building.getPolygon()));//(buildings.get(i).getPosition()));
		}
		 */
		return buildings;
	}
	
	public List<ParkingSpot> readParkingWithoutBlockFaces(String parkingFile, OsmContext context){
		List<ParkingSpot> parkings = new ArrayList<>();
		try{
			JsonNode rootNode = objectMapper.readTree(new File(parkingFile));
			Iterator<JsonNode> jsonArray = rootNode.elements();

			while(jsonArray.hasNext()){
				JsonNode currentNode = jsonArray.next();
				String id = currentNode.get("index").asText();
				Coordinate coords = new Coordinate(
						currentNode.get("lon").asDouble(), 
						currentNode.get("lat").asDouble());
				parkings.add(new ParkingSpot(context, coords, false, id));
			}
			
		} catch (Exception e){
			e.printStackTrace();
		}
		return parkings;
	}

	private static List<String> getNodesId(String[] nodesId){
		List<String> nodesIds = new ArrayList<>();
		for(int i = 0; i < nodesId.length; i ++){
			nodesIds.add(nodesId[i]);
		}
		return nodesIds;
	}

	public List<Road> parseRoadFile(String roadFile, Map<String, OsmNode> nodes){
		List<Road> roads = new ArrayList<>();

		try{
			JsonNode rootNode = objectMapper.readTree(new File(roadFile));
			int index = 0;
			while(true){
				JsonNode currentRoad = rootNode.get(String.valueOf(index));

				if(currentRoad == null){
					break;
				}
				Map<String, String> attributes = new HashMap<>();
				List<String> nodesId = new ArrayList<>();
				for(Iterator<String> iterator = currentRoad.fieldNames(); iterator.hasNext();){
					String key = iterator.next();
					if(key.equalsIgnoreCase("nodes")){
						String[] roadNodes = (currentRoad.get(key).asText()).split(" ");
						nodesId = getNodesId(roadNodes);
					} else {
						attributes.put(key, currentRoad.get(key).asText());
					}
				}
				ArrayList<OsmNode> osmNodes = new ArrayList<>();
				for(String nodeId : nodesId) {
					// Assume that node file has already been parsed.
					osmNodes.add(nodes.get(nodeId));
				}
				Road road = new Road(String.valueOf(index), attributes, osmNodes);
				roads.add(road);
				index++;
			}
		} catch (Exception e){
			System.out.println("Error in parsing road file: ");
			e.printStackTrace();
		}

		return roads;
	}
	/**********************************
	 * MANON
	 *********************************/
	
//	public ArrayList<Trajectory> readTrajectories(String trajectoriesFile){
//		ArrayList<Trajectory> trajectories = new ArrayList<>();
//		
//		try {
//			JsonNode rootNode = objectMapper.readTree(new File(trajectoriesFile));
//			
//			Iterator<JsonNode> trajectoriesArray = rootNode.elements();
//			
//			while(trajectoriesArray.hasNext()){
//				JsonNode currentTrajectory = trajectoriesArray.next();
//				
//				if(currentTrajectory == null){
//					break;
//				}
//				
//				JsonNode arrivalPoint = currentTrajectory.get("arrival");
//				// JsonObject arrivPointObject = arrivalPointElement.getAsJsonObject();
//				JsonNode startPoint = currentTrajectory.get("starting");
//				// JsonObject startPointObject = startPointElement.getAsJsonObject();
//				
//				Coordinate startCoord = new Coordinate(
//						arrivalPoint.get("x").asDouble(),
//						startPoint.get("y").asDouble());
//				
//				Coordinate arrivCoord = new Coordinate(
//						arrivalPoint.get("x").asDouble(),
//						arrivalPoint.get("y").asDouble());
//				
//				trajectories.add(new Trajectory(startCoord, arrivCoord));
//
//			}
//
//		} catch (Exception e) {
//			e.printStackTrace();
//		}
//		return trajectories;
//	}
	
	public Map<String, String> parseAgentFile(String id, String agentFile) {
		Map<String, String> attributes = new HashMap<>();
		
		try{
			JsonNode rootNode = objectMapper.readTree(new File(agentFile));
			JsonNode currentAgent = rootNode.get(id);
			
			Iterator<Map.Entry<String,JsonNode>> entries = currentAgent.fields();
			while(entries.hasNext()) {
				Map.Entry<String,JsonNode> entry = entries.next();
				attributes.put(entry.getKey(), entry.getValue().asText());
			}
			
		} catch (Exception e){
			System.out.println("Error in parsing building file: ");
			e.printStackTrace();
		}
		return attributes;
	}
	
}
